<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>c 与 数据结构 知识点复习</title>
      <link href="/2022/07/24/c%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2022/07/24/c%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-C-语言知识汇总"><a href="#第一章-C-语言知识汇总" class="headerlink" title="第一章  C 语言知识汇总"></a>第一章  C 语言知识汇总</h2><blockquote><p>本部分将简要介绍c语言的部分基础知识，参考书籍有《c primer plus》《计算机程序设计（贾伯琪）》等，参考网站有<a href="https://en.cppreference.com/">cppreference.com</a>；<a href="https://www.runoob.com/cprogramming/c-tutorial.html%E3%80%82%E5%A6%82%E6%9C%89%E9%94%99%E8%AF%AF%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%81%94%E7%B3%BB%E6%8C%87%E5%87%BA%EF%BC%8C%E8%B0%A2%E8%B0%A2%E3%80%82">https://www.runoob.com/cprogramming/c-tutorial.html。如有错误，可以联系指出，谢谢。</a></p></blockquote><h3 id="1-1-c-语言简介"><a href="#1-1-c-语言简介" class="headerlink" title="1.1  c 语言简介"></a>1.1  c 语言简介</h3><p>C语言简洁灵活，可移植性强，执行效率高，允许直接访问物理地址（慎重），能执行位操作等。可以说是比较接近机器语言的一门高级语言，同时有汇编语言和高级语言的优势。</p><p>程序员编写的代码首先是以文本文件形式存在，扩展名为.c ，为了得到可以直接执行的机器语言（.exe文件），需要由编译器把源代码转化为中间代码（比如目标文件代码 .obj 等），然后由链接器把中间代码和其他代码合成可执行文件（.exe）。</p><p>值得说明的是，中间代码相比最终目标缺少启动代码和库函数或者自己编写的头文件函数的链接，另外在自己编写头文件的时候需要注意的一点是不能重复编译，比如vs会默认在你自己编写的头文件中加一行 #pragma once 。链接器起到的作用就是把你的代码中引用的函数找到它的定义出处，也就是库或者你自己写的头文件。同时，这也是c 模块化特点的体现。</p><p>c的编译可以通过操作系统使用c编译器完成，比如linux安装的时候会有GCC的安装提示，编译的使用<strong>gcc inform.c</strong>命令，windows软件安装包并没有C编译器，需要下载Cygwin和MinGW，然后通过命令行的方式使用GCC编译器。</p><blockquote><p>GCC是GUN（一个开发大量免费Unix软件的集合）项目的一个产品，或称为GUN编译器集合，可以适应诸多硬件平台和操作系统，许多使用gcc的系统使用cc作为gcc的别名。（但cc是一个过时的命令）</p></blockquote><p>实际编程中，大部分程序员使用的是IDE，IDE可以看成一个集成开发环境，比如常用的VScode 、visual studio 等，利用IDE可以快速开发C程序，把之前的编译链接过程等简化，并且可以debug，还有其他的功能的插件。</p><h3 id="1-2-数据类型、运算符和表达式"><a href="#1-2-数据类型、运算符和表达式" class="headerlink" title="1.2 数据类型、运算符和表达式"></a>1.2 数据类型、运算符和表达式</h3><blockquote><p>首先简要介绍一下c语言的编写规范，以一段代码为例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">//链接库函数或者自己编写头文件，相当于把函数复制粘贴到这个位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y 1 <span class="comment">//宏定义，在预编译的时候会进行简单替换，把所有的y都替换成1 </span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">welcome</span><span class="params">(<span class="type">void</span>)</span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);<span class="comment">//见到那的字符输出格式，\n为转义字符需要</span></span><br><span class="line">&#125; <span class="comment">//函数定义，也可以在main函数之后定义，但是要在出现位置之前进行函数的声明，告诉系统这个标识符是自己写的一个函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;<span class="comment">//变量的声明</span></span><br><span class="line">    x=y;<span class="comment">//表达式语句</span></span><br><span class="line">    welcome();<span class="comment">//函数的调用</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NUM is %d\n&quot;</span>,x);<span class="comment">//输入输出语句</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//规范写法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*tips：注释有展示的两种方式*/</span></span><br></pre></td></tr></table></figure><p>C语言程序是由 main函数和若干其他函数的结合。编译首先找main函数，函数中语句以分号结尾，一条条执行，遇到函数会跳转到函数定义进行函数的执行，所有的标识符（对象）比如变量名、函数名等均需要声明，并且要说明数据类型，在c99、c11标准下声明的位置在使用之前即可，但最好放在开头。</p></blockquote><p><strong>C语言的语句</strong>：（可跳过）</p><ul><li>控制类语句：选择：if( )…… else ……         switch（）</li></ul><p>​                       循环：do ……while（）         while（）    break           continue</p><p>​                       其他：goto   return</p><ul><li>函数调用语句       max（）；</li><li>表达式语句        表达式；</li><li>空语句                      ；&#x2F;&#x2F;意义在于占位等</li><li>复合语句                 &#x2F;&#x2F;嵌套等</li></ul><p><strong>关键字</strong>：（可跳过）</p><p>数据类型：char  double  int float double long short void</p><p>​                enum signed  struct  union unsigned </p><p>控制类：参上</p><p>存储型：auto extern register static </p><p>其他：const sizeof typedef volatile</p><p><strong>数据类型</strong>：c语言需要提前说明变量类型来分配存储空间及确定可支持的操作。</p><p><strong>变量命名规则：</strong></p><p>至少前八个有效，大小写不同，<strong>第一个字符不能是数字</strong>，剩下的由下划线数字和字母组成。</p><p><strong>变量类型：</strong></p><p><strong>整数型</strong>：int （%d十进制表示&#x2F;%o八进制表示&#x2F;%0x十六进制表示）；</p><p>short（%hd）；long（%ld）；unsigned （%u）；unsigned short；unsigned long 。</p><p>unsigned表示无符号数，数的表示可以搜索有关补码反码等内容。</p><p>​             计数时使用unsigned范围会更大，如非必要用int就够了。</p><p>​             数据类型决定了存储方式，一般long（4字节）&gt;&#x3D;int(2或4字节)&gt;&#x3D;short(2字节). </p><p>​             常量表示可以使用123l或者123L表示其为长整型常量。&#x2F;<em>如显式使用内存地址时</em>&#x2F;</p><p>​             表示形式有十进制（%d），八进制（%o），十六进制（0x9F）（%x或%X）&#x2F;<em>%#x等可以显示前缀</em>&#x2F;</p><blockquote><p>字是设计计算机时给定的自然存储单位，现在基本上都是64位，也有32位。字长越大数据转移越快，允许访问内存越多。 同时伴随着整数溢出问题需要注意</p></blockquote><p><strong>实型数据</strong>：float（四字节，单精度型，七位有效数字）&#x2F;double（八字节，双精度，15到16位）</p><p>​                 表示形式有十进制（3.14），指数3.0e+5</p><blockquote><p>指数形式小数和整数不同时不存在。中间不能加空格。.2e4   .2   100.   都是合法的。       </p></blockquote><p><strong>字符型数据：char</strong></p><p>字符常量：’a‘；字符串常量“a”，末尾自动添加’&#x2F;0’；</p><p>​      转义字符：\b,退格  \n,\r(回车)，\t,\v(制表)，\,&#39;,\012,\x1f </p><p>​      字符型数据可以以字符或者整数形式输出（八位）,允许算数计算</p><p>数据类型转换：整型转化为int，实型转化为double，后者优先。可强制转化，eg：（float）5&#x2F;2&#x3D;2.5&#x2F;2 ！&#x3D; 2。</p><p><strong>算数运算：</strong></p><p>除法舍弃小数部分，按照优先级和结合性。</p><p><strong>赋值运算：</strong></p><p>自右向左的结合顺序（逆波兰式）。</p><h3 id="1-3-格式化输入输出函数："><a href="#1-3-格式化输入输出函数：" class="headerlink" title="1.3 格式化输入输出函数："></a>1.3 格式化输入输出函数：</h3><p>%12.3f  %g    &#x2F;<em>共12位，小数点后三位，自动舍去无意义零</em>&#x2F;</p><p>scanf的赋值抑制字符：*，将原本读出的数据舍弃。</p><p>用%c数输入单个字符时，空格和转义字符都算有效字符，故一般使用getchar（），如ch&#x3D;getchar（）</p><h3 id="1-4-运算符和表达式"><a href="#1-4-运算符和表达式" class="headerlink" title="1.4  运算符和表达式"></a>1.4  运算符和表达式</h3><h3 id="1-5-函数"><a href="#1-5-函数" class="headerlink" title="1.5  函数"></a>1.5  函数</h3><h3 id="1-6-数组和指针"><a href="#1-6-数组和指针" class="headerlink" title="1.6 数组和指针"></a>1.6 数组和指针</h3><h3 id="1-7-文件的输入输出"><a href="#1-7-文件的输入输出" class="headerlink" title="1.7 文件的输入输出"></a>1.7 文件的输入输出</h3><h3 id="1-8-结构体"><a href="#1-8-结构体" class="headerlink" title="1.8 结构体"></a>1.8 结构体</h3><h3 id="1-9-位操作"><a href="#1-9-位操作" class="headerlink" title="1.9 位操作"></a>1.9 位操作</h3><h3 id="1-10-预处理"><a href="#1-10-预处理" class="headerlink" title="1.10 预处理"></a>1.10 预处理</h3>]]></content>
      
      
      
        <tags>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web 学习记录</title>
      <link href="/2022/07/14/web%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/"/>
      <url>/2022/07/14/web%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-web方向入门记录"><a href="#CTF-web方向入门记录" class="headerlink" title="CTF web方向入门记录"></a>CTF web方向入门记录</h1><blockquote><p>本条记录web安全学习的入门内容，前期准备工作有burp suite的下载，pikachu靶场的搭建等，按照学习的路线进行记录，如有错误，还望指正。</p></blockquote><span id="more"></span><h2 id="密码爆破"><a href="#密码爆破" class="headerlink" title="密码爆破"></a>密码爆破</h2><h3 id="基于表单的暴力破解"><a href="#基于表单的暴力破解" class="headerlink" title="基于表单的暴力破解"></a>基于表单的暴力破解</h3><p>使用火狐浏览器搭建pikachu靶场后进行bp抓包，使用表单进行暴力破解，现实生活中对于暴力破解会有更多限制比如登录错误次数等。这里打开靶场点击基于表单的暴力破解，随便输入账号密码提交后使用bp监听抓包。</p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220716112109247.png" style="zoom:70%;/" /><p>然后点击action点击发送到intruder进行爆破</p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220716112204041.png" style="zoom:67%;" /><p>在intruder页面中可以进行爆破对象的选择，先点击clear然后在爆破位置重新add。</p><blockquote><p>其中攻击类型一栏有： </p><p>Sniper: 单变量设置一个payload攻击；</p><p>Battering ram: 设置两个变量，一个payload； </p><p>Pitchfork: 可以同时替换n个变量。不同个payload的值与变量一一对应。 （按照顺序对应，基本不用）</p><p>Cluster bomb: 可以同时替换n个变量。分别设置payload然后交叉破解。（一般使用）</p></blockquote><p>然后在payload页面里面导入字典，或者使用自带的字典，设置后点击start attack，通常暴力破解需要很长的时间，这里我们直接输入包含正确答案的几个选项简化过程</p><blockquote><p>一般我们会使用runtime file然后导入我们自己的字典</p></blockquote><p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220716113120840.png" alt="image-20220716113120840"></p><p>最后的结果可以看到在length一栏里正确答案会不同</p><p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220716113443853.png" alt="image-20220716113443853"></p><p>输入后成功</p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220716113626168.png" alt="image-20220716113626168" style="zoom:67%;" /><h3 id="验证码绕过（on-server）"><a href="#验证码绕过（on-server）" class="headerlink" title="验证码绕过（on server）"></a>验证码绕过（on server）</h3><p>为了防止暴力破解而产生的验证码可能因为长期不更新或者存在规律而无法生效，这里考虑的是验证码的持续有效性，比如php默认session中的验证码在24min内有效。</p><p>先确认验证码是否在服务器端存储不过期，方式就是send to repeater进行重放观察返回数据，重放的时候使用不同账号密码，如果仅显示账户密码错误而不是验证码错误那么说明验证码是在有效期内。</p><blockquote><p>反思：防止攻击的话考虑更改php.in设置验证码的过期时间。或者由于验证码是会发送给session的，考虑验证过一次之后直接销毁session。</p></blockquote><p><strong>验证码绕过(on client)</strong></p><p>在客户端的验证在失败之后会重新生成验证码，需要考虑这一类验证码的漏洞。</p><img src="https://pic3.zhimg.com/80/v2-3cfd6cf0b9b6bfaedb9347bb5ba523b7_720w.png?source=d16d100b" alt="img" style="zoom:67%;" /><p>客户端验证码常见问题有</p><ul><li><p>使用前端js实现验证码（本题），使逻辑暴露在客户端存在安全问题。</p></li><li><p>将验证码在cookie中泄露</p></li><li><p>验证码在前端源代码中泄露</p></li></ul><p>所以我们需要查看的就是验证码是不是在前端生成并且确认，查看源码可以发现确实，那么数据包直接绕过前端的验证码发送给服务器也没有问题，故直接按照之前的步骤爆破，（爆破过程中服务器并不会检查验证码是否错误）。</p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220717002058406.png" alt="image-20220717002058406" style="zoom: 67%;" /><p>···</p><p><strong>token防爆破？</strong></p><img src="https://picx.zhimg.com/80/v2-99a057b68f9108c06dab5f47e893dd83_720w.png?source=d16d100b" alt="img" style="zoom:67%;" /><p>token是<strong>服务器</strong>生成的一个字符串作为客户端请求的标识，在新登录的时候需要提交正确的token值。本题中下一次登录的token在上一次的服务器返回包里，故单线程进行。</p><blockquote><p>简单token的组成：uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串。为防止token泄露）。</p><p>token验证的基本机制：<br>1、当客户端第一次请求时，发送用户信息至服务器(用户名、密码)，服务器对用户信息签名，再将这个签名和数据一起作为Token一起返回给客户端。<br>2、服务器不保存Token，客户端保存Token(比如放在 Cookie 里或者 Local Storage 里)<br>3、当客户端再次发送请求时，在请求信息中将Token一起发给服务器<br>4、服务器用同样的HS256算法等，对数据再进行一次签名，和客户端返回的Token的签名进行比较，如果验证成功，就向客户端返回请求的数据</p></blockquote><p>token是无法防止暴力破解的，所以这一次我们加上对token的爆破，即我们把抓包内容发送到intruder中，然后在grep-extract中添加过滤条件——token值。</p><p>首先是抓包的数据，发现随机生成的token值</p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220716154700436.png" alt="image-20220716154700436" style="zoom:67%;" /><p>把option中的线程设置为一，这是因为token的变化性，不允许程序的并发运行。另外由于token储存在html包的body的hidden部分，所以要把redirection（重定向）选择always然后便可以达到绕过token经行破解的目的。</p><p><img src="https://pica.zhimg.com/80/v2-939e7c5bc8cb29c4dcc6cd73638da849_720w.png?source=d16d100b" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-b2326ca5bbc6fcfe54a33faf3c34c1b1_720w.png?source=d16d100b" alt="img"></p><p>在grep-extract中找到token的值，这里直接搜索在字段 value&#x3D;“后面的内容，点击refetch response会跳转到含有token的页码。然后点击正确的token值。</p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220716155800506.png" style="zoom:67%;" /><p>在payload设置中，前面的集合正常设置，token集合的payload类型更改为递归攻击 recursive grep</p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220716160612598.png" alt="image-20220716160612598" style="zoom:67%;" /><p>然后把初始的token值传入：</p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220716175252529.png" alt="image-20220716175252529" style="zoom:67%;" /><p>开始攻击后发现有一个成功爆破。</p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220717004451945.png" alt="image-20220717004451945" style="zoom:67%;" /><h2 id="XSS跨站脚本攻击（Cross-Site-Scripting）"><a href="#XSS跨站脚本攻击（Cross-Site-Scripting）" class="headerlink" title="XSS跨站脚本攻击（Cross Site Scripting）"></a><strong>XSS跨站脚本攻击（</strong>Cross Site Scripting）</h2><p>恶意攻击者往 WEB 页面里插入恶意 HTML 代码，当用户浏览该页之时，嵌入其中 Web 里面的 HTML 代码会被执行，从而达到恶意攻击用户的特殊目的。主要发生在前端，危害较大。主要是对输入输出的内容没有进行处理。</p><blockquote><p>1.反射型XSS：交互的数据不存数据库而是所见即所得，一般出现在查询页面</p><p>2.存储型XSS：永久存储在数据库中，比如留言板、注册页面</p><p>3.DOM型XSS：不与后台服务器进行数据交互，通过DOM操作前端代码，属于反射型</p><p>实际攻击中可能有用户访问xss页面触发攻击脚本，执行后窃取用户的数据发送给攻击者的服务器，然后攻击者利用这个数据发送给站点进行用户的伪造。</p><p>xss的漏洞测试流程：找到查询点留言板等，之后输入特殊字符和唯一识别的字符，然后提交查看是否有返回的源码，如果基本上没有什么安全措施的话可构造闭合的payload。</p></blockquote><p>而在靶场中我们测试的目标就是检测相应的xss漏洞。步骤大概是在网站的交互输入观察页面是否会对内容进行转义，然后通过源码来查看是否有构造闭合的条件，提交相应的脚本代码然后执行观测结果，执行成功说明有相应的xss漏洞。</p><p>首先需要了解js的一些内容，不同浏览器也会集成不同的js解释引擎，这里使用的是火狐的spidermonkey。</p><p>嵌入在 HTML 中的 JS 代码通常有以下几种形式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">直接插入代码块</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">加载外部 JS 文件</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;test.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">使用 HTML 标签中的事件属性</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(&#x27;Hello&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>js的数据类型</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过“ <span class="keyword">new</span> ”来声明变量类型：</span><br><span class="line"><span class="keyword">var</span> pi=<span class="keyword">new</span> <span class="title class_">String</span>;#字符串</span><br><span class="line"><span class="keyword">var</span> pi=<span class="keyword">new</span> <span class="title class_">Number</span>;#数字</span><br><span class="line"><span class="keyword">var</span> pi=<span class="keyword">new</span> <span class="title class_">Boolean</span>;#布尔值</span><br><span class="line"><span class="keyword">var</span> pi=<span class="keyword">new</span> <span class="title class_">Array</span>;#数组</span><br><span class="line"><span class="keyword">var</span> pi=<span class="keyword">new</span> <span class="title class_">Object</span>;#对象</span><br></pre></td></tr></table></figure><p>赋值不需要指定类型:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pi=<span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">var</span> pi=<span class="string">&#x27;ratio of the circumference of a circle to its diameter&#x27;</span>;</span><br></pre></td></tr></table></figure><p>Undefined 和 Null:</p><p>简单区分，前者为有对象没有值，后者为没有对象。</p><p>所有的JS变量都是对象但是对象声明的字符喜欢和直接赋值的字符串并不严格相等。</p><p><strong>JavaScript 编程逻辑</strong></p><p>if 条件语句：switch 条件语句：for&#x2F;for in 循环语句：while&#x2F;do while 循环语句：和一般的编程语言（c）类似</p><p><strong>JavaScript 打印数据</strong></p><ul><li><strong>window.alert()弹出警告框</strong></li><li><strong>document.write()写入HTML文档</strong></li><li><strong>console.log()写入浏览器控制台</strong></li></ul><h3 id="反射型xss-get"><a href="#反射型xss-get" class="headerlink" title="反射型xss(get)"></a><strong>反射型xss(get)</strong></h3><img src="https://pic3.zhimg.com/80/v2-7843c673c06d3c0db826e88d2d8b4c61_720w.png?source=d16d100b" alt="img" style="zoom:67%;" /><p>我们查看源码，发现有关设置是直接输入，所用方式为get。，</p><p><img src="https://pica.zhimg.com/80/v2-68a5095b7976b60da44056fe4432745e_720w.png?source=d16d100b" alt="img"></p><ul><li><p>**<script> 标签:**用于定义客户端脚本，比如 JavaScript</p></li><li><p>**<div>标签:**用于组合块元素,定义文档中的一个标签部分或者一个区域部分。</p></li><li><p>:定义一个段落</li><li><!--...-->：注释</li><li><form> ：创建供用户**输入**的 HTML 表单。</li></ul><p>这样我们大概可以了解这些语句的目的了。由于这里所用的方式是get，我们直接在url中插入有关脚本。</p><p><img src="https://pic2.zhimg.com/80/v2-6f25e1cd0a2b143097a27243d0dfdafe_720w.png?source=d16d100b" alt="img"></p><img src="https://pic2.zhimg.com/80/v2-4fabedec0b859f792716759d7c9a3a29_720w.png?source=d16d100b" alt="img" style="zoom:50%;" /><p>如果是在输入框中输入的话会有字数限制，其实正常的步骤就是先在输入框中输入特殊字符然后看前端的处理，这里我们可以打开源码，搜索到输入内容。</p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220717120613958.png" alt="image-20220717120613958" style="zoom:67%;" /><p>可以看到这里并没有对输入内容进行处理，但是展开上面的输入内容发现在输入框中限制了字数，这种在前端的辅助安全措施并不能有效抵御攻击，直接找到设定长度的代码然后修改，再输入闭合语句。</p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220717120823592.png" alt="image-20220717120823592" style="zoom: 50%;" /><blockquote><p>这里可以看出由于后端没有对输入的内容进行处理，故存在这个漏洞，由于是反射型的xss，刷新之后对系统也没啥影响了，但是通过url的输入可以达到弹窗或者其他的js功能。另外这个长度的限制也可以使用bp抓包后修改，这个和get方式有关。</p><p>实际中的攻击是通过发送给别人一串带有xss（get）的url发送给目标执行之后，直接对服务器执行一个恶意的脚本。</p></blockquote><p><strong>反射性xss(post)</strong></p><p><img src="https://pic2.zhimg.com/80/v2-8e9775a829e31212ca58f6a469048ff1_720w.png?source=d16d100b" alt="img"></p><p>按照提示登陆后在框框里输入我们之前输入的那个脚本。</p><p><img src="https://pic4.zhimg.com/80/v2-780017aeffe613e52e6d8f1d6531a544_720w.png?source=d16d100b" alt="img"></p><blockquote><p>反射性xss一般在查询接口 由于后台可能存在过滤措施所以构造的script可能会被过滤掉，可以尝试不同的script来绕开后台的过滤机制。</p></blockquote><p>post类型的xss的攻击场景是 bob在正常访问页面的时候访问了恶意服务器的表单页面，恶意服务器发送自动post的恶意代码后被bob post到了正常的服务器上。</p><p><strong>存储型xss</strong></p><blockquote><p>存储型XSS和反射型XSS形成的原因是一样的，不同的是存储型XSS下攻击者的可以将脚本注入到后台存储起来，构成更加持久的危害</p></blockquote><p><img src="https://pica.zhimg.com/80/v2-25867e4bb06116d704a01fd65b4c5a41_720w.png?source=d16d100b" alt="img"></p><p>我们在留言板中输入相同的payload，出现相同结果，但是值得注意的是。检测成功后我们不输入内容点击提交，出现以下界面。</p><p><img src="https://pic2.zhimg.com/80/v2-2d61b4a399d32b8cac9c317ab8b0d35f_720w.png?source=d16d100b" alt="img"></p><p>这说明我们的payload已经被储存在数据库中，不被删除则被一直执行。这里的漏洞其实考虑了sql的注入但是没有对输出的数据进行处理。</p><p><strong>DOM型xss</strong></p><blockquote><p>dom  把html的标签看成dom树，即提供了文档的结构化描述。并且定义了方法可以从程序中对结构进行访问。</p></blockquote><p>之前的payload并没有成功，我们先查看一下网页的源代码</p><p><img src="https://pica.zhimg.com/80/v2-0aa0695cef7706519e06c8dbd3e99414_720w.png?source=d16d100b" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-8c7abf47288cca9da1ec0a4642ca26f4_720w.png?source=d16d100b" alt="img"></p><p>找到有关输入的部分，看到网页自己定义了一个domxss的函数，我们找一下相关的定义（上搜索栏）。</p><p><img src="https://pic3.zhimg.com/80/v2-bdeeabab879e01998978baa94edd802b_720w.png?source=d16d100b" alt="img"></p><p>这里的domxss的函数是通过dom将text节点的值作为变量赋给了dom节点，所以我们输入的内容会被赋到dom上，这里提示闭合(闭合的是a herf标签)。</p><p>如果输入'><img src="#" οnerrοr=alert(/xss/)" >或者'><img src="#" onmouseover=alert(/xss/)" >图片不存在则加载错误，弹框。</p><blockquote><p>onmouseover 事件：鼠标指针移动到图片后执行Javascript代码                                                <strong>onerror</strong>事件：一种老式的标准的在网页中捕获Javascript 错误的方法，它在加载外部文件（文档或图像）发生错误时被触发</p></blockquote><p><img src="https://pica.zhimg.com/80/v2-4ef6ab0cfe5f78ac7430bc1559111410_720w.png?source=d16d100b" alt="img"></p><p>观察一下代码</p><p><img src="https://pic2.zhimg.com/80/v2-8c7abf47288cca9da1ec0a4642ca26f4_720w.png?source=d16d100b" alt="img"></p><p><img src="https://pica.zhimg.com/80/v2-ce2ae3d936febb01871355767510aadf_720w.png?source=d16d100b" alt="img"></p><blockquote><p>至于为什么输入的是单引号不是双引号，不知且确实不行</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入&#x27; onclick=&quot;alert(/xss/)&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="https://pica.zhimg.com/80/v2-66a62bac80e697a22237f1e18eb68701_720w.png?source=d16d100b" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-39d79b43de5af3075216a4568beb0d1b_720w.png?source=d16d100b" alt="img"></p><p>在这里我们使用了超链接，观察一下代码</p><p><img src="https://pic2.zhimg.com/80/v2-4e458123cc15c43949eeb4855853e773_720w.png?source=d16d100b" alt="img"></p><p>这是在点超链接之前：</p><p><img src="https://pic2.zhimg.com/80/v2-24216c97428567f05881dabca0f64980_720w.png?source=d16d100b" alt="img"></p><p>在点击之后事件消失。相当于a herf实现了一个超链接的内容。</p><p><strong>DOM型xss-x</strong></p><p><img src="https://pic1.zhimg.com/80/v2-8971e10548d5fe2a63a46aa19ab1638b_720w.png?source=d16d100b" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-4f32ee196c54ad9d225bb5a2f149803f_720w.png?source=d16d100b" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-0769e65f87f9ec0517422029d8c04d3d_720w.png?source=d16d100b" alt="img"></p><p>盲打即不前端显示，进入后台（提示的地址修改url）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入&lt;script&gt;alert(/xss/)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://pic3.zhimg.com/80/v2-dacee5041c943b80fb4cdab0311c19b3_720w.png?source=d16d100b" alt="img"></p><p><strong>xss之过滤</strong></p><p><img src="https://pic2.zhimg.com/80/v2-cb8a4f3b886ca6c897328f687e0309e1_720w.png?source=d16d100b" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入&lt;script&gt;alert(/xss/)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>发现被过滤，按照之前说的，修改大小写</p><blockquote><p>常用方法也有使用注释如<scri pt>alert（/xss/）</scri pt></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入&lt;SCript&gt;alert(/xss/)&lt;/SCript&gt;</span><br></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/80/v2-c7078620519cbe3ee1a68ee21914fb09_720w.png?source=d16d100b" alt="img"></p><p><strong>xss之htmlspecialchars</strong></p><p><img src="https://pic1.zhimg.com/80/v2-ea7594e633b7c2bb975acd9cead11a8f_720w.png?source=d16d100b" alt="img"></p><blockquote><p>htmlspecialchars:对一些符号编码成HTML编码防止注入。 预定义的字符是 & 成为 &amp " 成为 &quot ' 成为 &#039 < 成为 &lt > 成为 &gt 可用引号类型 ENT_COMPAT：默认，仅编码双引号 ENT_QUOTES：编码双引号和单引号 ENT_NOQUOTES：不编码任何引号</p></blockquote><p>其中有关引号的编码有时候只能编码单引号或者双引号或者不编码任何引号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; onclick=&quot;alert(/xss/)&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="https://pica.zhimg.com/80/v2-19908a2202b4f06486431e29651db254_720w.png?source=d16d100b" alt="img"></p><p><strong>xss之href输出</strong></p><p><img src="https://pica.zhimg.com/80/v2-f7de927758f81d1f394bca07476522f9_720w.png?source=d16d100b" alt="img"></p><p>按照提示我们先查询一下a标签</p><ul><li><a> 标签定义超链接，用于从一张页面链接到另一张页面。</li><li><a> 元素最重要的属性是 href 属性，它指示链接的目标。</li></ul><p>我们这里直接使用js伪协议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascript:alert(/xss/)</span><br></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/80/v2-6a9922ff4d87fc3a3b247df6b06af491_720w.png?source=d16d100b" alt="img"></p><blockquote><p>伪协议不同于ftp http等，是为了关联应用如tencent、data、js js的伪协议，URL的主体为不同的js代码，由js的解释器运行，将最后的字符串作为新文档显示出来。浏览器打开如果URL代码的返回值不是undefined，则前页链接代替返回值。或者仅仅执行动作（alert）。通过void(0)可以生成一个新的空窗口，不显示文档。</p></blockquote><p><strong>xss之js输出</strong></p><p><img src="https://pic3.zhimg.com/80/v2-0c8f8b6770e4e2e0ed1d25752dd5d9b3_720w.png?source=d16d100b" alt="img"></p><p>我们看一下源代码</p><p><img src="https://pic1.zhimg.com/80/v2-141bfdeabb0fb1255c39ea908a7c0063_720w.png?source=d16d100b" alt="img"></p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>跨站请求伪造：一般攻击者会伪造一个请求，欺骗目标用户进行点击。这里并没有直接获得用户的登陆账号密码什么的，而是借助用户自己的权限实现攻击。</p><p>举例来说如果一个网站的用户密码的更改方式是点击一个包含更改信息的URL链接，那我们可以伪造一个类似的链接，并且祈祷被攻击者刚好在登陆该网站之后点击了我们的链接，从而达到改他密码的目的。</p><p>一般网页对应的预防措施有：</p><ul><li>对敏感信息的操作增加安全的token；</li><li>对敏感信息的操作增加安全的验证码；</li><li>对敏感信息的操作实施安全的逻辑流程，比如修改密码时，需要先校验旧密码等。</li></ul><p><strong>CSRF(get) login</strong></p><p><img src="https://pic3.zhimg.com/80/v2-95d3f106c59c587b899c9f694ff05f61_720w.png?source=d16d100b" alt="img"></p><p>按照提示登陆一个账号</p><p><img src="https://pic4.zhimg.com/80/v2-8293d46b02b82bc4368caa4e95af4a9a_720w.png?source=d16d100b" alt="img"></p><p>修改个人信息，然后老规矩用burpsuite抓包</p><p><img src="https://pic1.zhimg.com/80/v2-c9c5c4c3b1963009343bf13ee5c38b8d_720w.png?source=d16d100b" alt="img"></p><p>可以看到第一行：</p><p>GET /pikachu-master/pikachu-master/vul/csrf/csrfget/csrf_get_edit.php?sex=gril&phonenum=11111111&add=aaa&email=aaa%<a href="http://40123.com/">40123.com</a>&submit=submit HTTP/1.1</p><p>我们按照这个格式自己构造一个payload</p><p>GET /pikachu-master/pikachu-master/vul/csrf/csrfget/csrf_get_edit.php?sex=boy&phonenum=222222&add=bbb&email=ccc%<a href="http://40123.com/">40123.com</a>&submit=submit HTTP/1.1</p><p>然后在自己登陆状态下复制访问。</p><p><img src="https://pic1.zhimg.com/80/v2-893910f66a3d180db9e2470fb6af11c4_720w.png?source=d16d100b" alt="img"></p><p>信息修改成功，实际攻击过程就是用抓包或者其他的方法构造这样的链接。</p><p><strong>CSRF(post) login</strong></p><p><img src="https://pic3.zhimg.com/80/v2-de3459b6b97b6b8f1fb9aaa89893c95f_720w.png?source=d16d100b" alt="img"></p><p>按照上面的步骤抓包</p><p><img src="https://pica.zhimg.com/80/v2-f564c34b895fe69a3c2a55aee9741cd2_720w.png?source=d16d100b" alt="img"></p><p>这里我们可以很明显感受得到post要比get要难搞，它不会直接把参数放在url里。这样我们就只能搞一个假的网页了。</p><p>自己写网页比较麻烦，要借助服务器，购买域名然后对网页进行部署。有一个软件叫CRSFtester是可以根据抓包情况自己生成一个恶意的html网页，但是下载比较麻烦，这一题我们暂时掠过，主要思路就是通过构建一个自动修改信息的网页，然后让被攻击者点击这个网页的链接。</p><p><strong>CSRF Token login</strong></p><p>页面和之前一样。</p><p><img src="https://pic3.zhimg.com/80/v2-f61f84d397e3caf7fb7d819c9869ce0e_720w.png?source=d16d100b" alt="img"></p><p>可以看到带的token（随机）使敏感信息没那么容易被篡改。</p><p>由于token值的随机性，攻击无法成功。</p><h2 id="Sql-Inject-SQL注入"><a href="#Sql-Inject-SQL注入" class="headerlink" title="Sql Inject(SQL注入)"></a>Sql Inject(SQL注入)</h2><p>主要形成的原因是在数据交互中，前端的数据传入到后台处理时，没有做严格的判断，导致其传入的“数据”拼接到SQL语句中后，被当作SQL语句的一部分执行。从而导致数据库受损（被脱库、被删除、甚至整个服务器权限沦陷）。</p><p> 在构建代码时，一般会从如下几个方面的策略来防止SQL注入漏洞：</p><p>​                        1.对传进SQL语句里面的变量进行过滤，不允许危险字符传入；</p><p>​                        2.使用参数化（Parameterized Query 或 Parameterized Statement）；</p><p>​                        3.还有就是,目前有很多ORM框架会自动使用参数化解决注入问题,但其也提供                     了"拼接"的方式,所以使用时需要慎重!    </p><p><img src="https://pic1.zhimg.com/80/v2-157426feb0ebbda42abbdc451a423bb6_720w.png?source=d16d100b" alt="img"></p><p>用bp抓包然后send到 repeater中，修改id的值 1 or 1#，点击go，然后查看render</p><p><img src="https://pic1.zhimg.com/80/v2-a2a7f26889cd2a0778cbe6304a048f02_720w.png?source=d16d100b" alt="img"></p><p>所有信息暴露。这里说明有SQL注入。</p><p><strong>字符型注入</strong></p><p><img src="https://picx.zhimg.com/80/v2-425f471ecb6ee71237425d9b2c0bc5a3_720w.png?source=d16d100b" alt="img"></p><p>构造一个回路加一个真语句</p><p><img src="https://picx.zhimg.com/80/v2-108ad0477b95f226df7e4c4c4527dfa4_720w.png?source=d16d100b" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-9b9b02e557b6347ee5dbf6f2a8e84fb9_720w.png?source=d16d100b" alt="img"></p><p><strong>搜索型注入</strong></p><p><img src="https://pic2.zhimg.com/80/v2-ae368484ece3e6aa303bd554921cb8c3_720w.png?source=d16d100b" alt="img"></p><p>搜索型：select username from user where username like '%{$username}%';</p><p>按照提示中的%%</p><p><img src="https://picx.zhimg.com/80/v2-37dfcd56db69bbd3360f2fdd86df4370_720w.png?source=d16d100b" alt="img"></p><p><strong>x</strong></p><p><img src="https://pic1.zhimg.com/80/v2-4d0f36c562fa129f1e48a1e889b676b1_720w.png?source=d16d100b" alt="img"></p><p>不知道什么型：select username from user where username like （‘ ’）;</p><p><img src="https://pic4.zhimg.com/80/v2-c59ab4a171bfe42b8fd205f486f3c317_720w.png?source=d16d100b" alt="img"></p><p>kobe') order by 2## 爆字段列数 </p><p>kobe')union select database(),user()## 爆数据库名和用户名 </p><p>kobe') union select database(),group_concat(table_name) from information_schema.tables where table_schema=database()## 爆数据表 </p><p>kobe') union select database(),group_concat(column_name) from information_schema.columns where table_name='users'## 爆字段 </p><p>kobe') union select database(),group_concat(username,':',password) from users## 爆内容</p><p>总结来说，构造闭合，并且要用#将后面原本正常语句注释掉</p><p><strong>login</strong></p><p><img src="https://pic3.zhimg.com/80/v2-050e14a88c9b4e5c31c92eb91bc61435_720w.png?source=d16d100b" alt="img"></p><h2 id="File-Inclusion-文件包含漏洞"><a href="#File-Inclusion-文件包含漏洞" class="headerlink" title="File Inclusion(文件包含漏洞)"></a>File Inclusion(文件包含漏洞)</h2><p><strong>1.本地文件包含漏洞：</strong>仅能够对服务器本地的文件进行包含，由于服务器上的文件并不是攻击者所能够控制的，因此该情况下，攻击着更多的会包含一些 固定的系统配置文件，从而读取系统敏感信息。很多时候本地文件包含漏洞会结合一些特殊的文件上传漏洞，从而形成更大的威力。</p><p><strong>2.远程文件包含漏洞：</strong>能够通过url地址对远程的文件进行包含，这意味着攻击者可以传入任意的代码，这种情况没啥好说的，准备挂彩。   </p><h2 id="不安全的文件下载"><a href="#不安全的文件下载" class="headerlink" title="不安全的文件下载"></a>不安全的文件下载</h2><p><strong>切记：所有与前端交互的数据都是不安全的，不能掉以轻心</strong></p><p>一般后台下载文件是直接将文件名称并入下载文件中的路径，但如果名字有问题 ，比如改成了一个路径指向后台敏感信息，则可能导致信息泄露。     </p>]]></content>
      
      
      
        <tags>
            
            <tag> web ctf pikachu </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
