<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>c 与 数据结构知识点复习Ⅰ</title>
      <link href="/2022/07/29/c%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2022/07/29/c%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="C-语言知识汇总"><a href="#C-语言知识汇总" class="headerlink" title="C 语言知识汇总"></a>C 语言知识汇总</h2><blockquote><p>本部分将简要介绍c语言的部分基础知识，参考书籍有《c primer plus》《计算机程序设计（贾伯琪）》等，参考网站有<a href="https://en.cppreference.com/">cppreference.com</a>；<a href="https://www.runoob.com/cprogramming/c-tutorial.html%E3%80%82%E5%A6%82%E6%9C%89%E9%94%99%E8%AF%AF%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%81%94%E7%B3%BB%E6%8C%87%E5%87%BA%EF%BC%8C%E8%B0%A2%E8%B0%A2%E3%80%82">https://www.runoob.com/cprogramming/c-tutorial.html。如有错误，可以联系指出，谢谢。</a></p></blockquote><h3 id="c-语言简介"><a href="#c-语言简介" class="headerlink" title="c 语言简介"></a>c 语言简介</h3><p>C语言简洁灵活，可移植性强，执行效率高，允许直接访问物理地址（慎重），能执行位操作等。可以说是比较接近机器语言的一门高级语言，同时有汇编语言和高级语言的优势。</p><p>程序员编写的代码首先是以文本文件形式存在，扩展名为.c ，为了得到可以直接执行的机器语言（.exe文件），需要由编译器把源代码转化为中间代码（比如目标文件代码 .obj 等），然后由链接器把中间代码和其他代码合成可执行文件（.exe）。</p><p>值得说明的是，中间代码相比最终目标缺少启动代码和库函数或者自己编写的头文件函数的链接，另外在自己编写头文件的时候需要注意的一点是不能重复编译，比如vs会默认在你自己编写的头文件中加一行 #pragma once 。链接器起到的作用就是把你的代码中引用的函数找到它的定义出处，也就是库或者你自己写的头文件。同时，这也是c 模块化特点的体现。</p><p>c的编译可以通过操作系统使用c编译器完成，比如linux安装的时候会有GCC的安装提示，编译的使用<strong>gcc inform.c</strong>命令，windows软件安装包并没有C编译器，需要下载Cygwin和MinGW，然后通过命令行的方式使用GCC编译器。</p><blockquote><p>GCC是GUN（一个开发大量免费Unix软件的集合）项目的一个产品，或称为GUN编译器集合，可以适应诸多硬件平台和操作系统，许多使用gcc的系统使用cc作为gcc的别名。（但cc是一个过时的命令）</p></blockquote><p>实际编程中，大部分程序员使用的是IDE，IDE可以看成一个集成开发环境，比如常用的VScode 、visual studio 等，利用IDE可以快速开发C程序，把之前的编译链接过程等简化，并且可以debug，还有其他的功能的插件。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>首先简要介绍一下c语言的编写规范，以一段代码为例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">//链接库函数或者自己编写头文件，相当于把函数复制粘贴到这个位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y 1 <span class="comment">//宏定义，在预编译的时候会进行简单替换，把所有的y都替换成1 </span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">welcome</span><span class="params">(<span class="type">void</span>)</span>&#123; </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);<span class="comment">//见到那的字符输出格式，\n为转义字符需要</span></span><br><span class="line">&#125; <span class="comment">//函数定义，也可以在main函数之后定义，但是要在出现位置之前进行函数的声明，告诉系统这个标识符是自己写的一个函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="type">int</span> x;<span class="comment">//变量的声明</span></span><br><span class="line"> x=y;<span class="comment">//表达式语句</span></span><br><span class="line"> welcome();<span class="comment">//函数的调用</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;NUM is %d\n&quot;</span>,x);<span class="comment">//输入输出语句，这里的%d可以看成一种特殊字符，控制输出的位置和格式</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//规范写法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*tips：注释有展示的两种方式*/</span></span><br></pre></td></tr></table></figure><p>C语言程序是由 main函数和若干其他函数的结合。编译首先找main函数，函数中语句以分号结尾，一条条执行，遇到函数会跳转到函数定义进行函数的执行，所有的标识符（对象）比如变量名、函数名等均需要声明，并且要说明数据类型。</p><p>在c99、c11标准下数据声明的位置在使用之前即可，但最好一起放在开头。</p></blockquote><p><strong>C语言的语句</strong>：</p><p>语句是执行的基本单位，以<strong>分号</strong>隔离开。</p><ul><li>控制类语句：选择：if( )…… else ……         switch（）</li></ul><p>​                       循环：do ……while（）         while（）    break           continue</p><p>​                       其他：goto   return</p><ul><li>函数调用语句       max（）；</li><li>表达式语句        表达式；</li><li>空语句                      ；&#x2F;&#x2F;意义在于占位等</li><li>复合语句                 &#x2F;&#x2F;嵌套等</li></ul><p><strong>关键字</strong>：</p><p>关键字是变量等命名需要避开的字，在语言中有自己的定义。</p><p>数据类型：char  double  int float double long short void</p><p>​                enum signed  struct  union unsigned </p><p>控制类：参见语句部分出现的单词。</p><p>存储型：auto  extern  register  static </p><p>其他：const  sizeof  typedef  volatile</p><p><strong>数据类型</strong>：</p><p>c语言需要提前说明变量类型来分配存储空间及确定可支持的操作。其中基本类型有整型、实型、字符型；构造类型有 数组、结构、枚举、共用体；另外还有指针类型和空类型。</p><p>首先介绍数据的载体，常量和变量，常量无法改变，类型一般按照书写形式判断，比如10就是整型，或者10L是长整型（一般也不需要那么长，可能显式使用内存等情况需要）；变量需要有变量名和变量值，类似于代数。<strong>变量命名规则：</strong>不能过长，但至少前八位有效，对<strong>大小写</strong>敏感，<strong>首字符不能是数字</strong>，剩下的由下划线数字和字母组成。变量在引用之前必须声明，函数也是，必须告知编译器这个符号是什么，分配多大存储空间。</p><p><strong>整型数据</strong>：</p><p> int （%d十进制表示；%o八进制表示；%0x十六进制表示）；</p><p>short（%hd）；long（%ld）；unsigned （%u）；unsigned short；unsigned long 。</p><p>unsigned表示无符号数，数的表示可以搜索有关补码反码等内容。</p><p> 数据类型决定了存储方式，一般long（4字节）&gt;&#x3D;int(2或4字节)&gt;&#x3D;short(2字节). </p><blockquote><p>整型常量可以以十进制、八进制、十六进制表示</p></blockquote><p><strong>实型数据</strong>：</p><p>float（四字节，单精度型，七位有效数字）；double（八字节，双精度，15到16位）</p><p>表示形式：十进制小数（3.14），指数3.0e+5</p><blockquote><p>指数形式表示规则：小数和整数不同时不存在。中间不能加空格。.2e4   .2   100.   都是合法的。       </p></blockquote><p><strong>字符型数据：</strong></p><p><strong>char</strong>：字符常量：’a‘；字符串常量“apple”，末尾自动添加’&#x2F;0’，实际表示“apple&#x2F;0”；</p><p>转义字符：表示和本身不同的一些内容比如：\b,退格  \n,\r(回车)，\t,\v(制表)，</p><blockquote><p>另外用转义字符答应ascii也可以比如<code>printf(&quot;\x4f\x4b&quot;)</code>等价于<code>printf(&quot;OK&quot;)</code></p><p>字符型数据可以以字符或者<strong>整数形式</strong>输出（八位）,允许算数计算（‘a’+1）</p></blockquote><p><strong>算数运算：</strong></p><p>基本的算数运算加、减、乘、除、求余数（模），特殊的是除法舍弃小数部分。另外还有与、或、异或等，可以自行查询真值表，在后面位运算里面再作解释。</p><img src="https://cdn.jsdelivr.net/gh/A-624/blog_img/image-20220728212212671.png" alt="image-20220728212212671" style="zoom:67%;" /><p>图中最左边是赋值运算符，最终结果会赋值到变量a上。第二列是自增自减运算符，第一行等价于 a&#x3D; a+1，符号放在前表示在参与运算前改变值，反之之后，这是c语言较为独特的用法，很容易出错。comparison是比较运算符，表达式的值位真假也就是1、0；右边第二列是成员运算符，在介绍指针的时候会说明。</p><blockquote><p>逗号是顺序求值，例如 <code>a+=a-=a*a</code> 当a&#x3D;12时，根据赋值运算符右结合，答案是-264，</p></blockquote><p>用运算符和括号把运算对象连接起来的称为表达式，表达式求值遵循优先级（实际可以自己加括号）。另外除了赋值运算符和条件运算符都是左结合（自左到右），例如 a&#x3D;1 中赋值的对象是变量a。</p><p><strong>数据类型转换</strong>：运算中一般整型转化为int，实型转化为double，后者优先。可强制转化，eg：<code>（float）5/2=2.5 ！= 2</code> <code>（float）(5/2)= 2</code>。另外一些数据的强制转换需要考虑符号位，是否要进行符号扩展以及是否会溢出等。另外一般浮点数转化为整数会舍弃小数，具体的还要看编译器，自己试一下。</p><p><strong>变量的作用域和生存期</strong>：指有效范围和事件，局部变量是在函数或者语句内部定义（不建议）的变量，比如某个函数定义内部的变量，全局变量是在所有函数（包括main）之外定义的变量，整个文件都共用，但是如果和局部变量重名则局部优先，所以要少用。另外变量的存储器类型有auto(缺省);register（形参，速度快）;static（静态局部变量）;extern（外部变量，比如多文件使用的时候）</p><blockquote><p>extern 举例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> a,b;</span><br><span class="line">    a=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a=<span class="number">12</span>,b=<span class="number">2</span>;</span><br><span class="line"><span class="comment">//或者在另外一个文件中进行最后一行的声明</span></span><br></pre></td></tr></table></figure><p>static限制其他文件的引用和被引用</p></blockquote><p><strong>编译预处理</strong>：#开头，宏定义（简单替换），文件包含 等，主要介绍条件编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">if</span> (def )</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*比如按照要求让全部字母大写或者小写输出*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> 要求 1 <span class="comment">//这里表示大写输出</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> tar[<span class="number">80</span>],c;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    gets(tar);</span><br><span class="line">    <span class="keyword">while</span> ((c=tar[i])!<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">       <span class="meta"># <span class="keyword">if</span> 要求</span></span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;z&#x27;</span>) c-=<span class="number">32</span>;</span><br><span class="line">       <span class="meta"># <span class="keyword">else</span> </span></span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;Z&#x27;</span>) c+=<span class="number">32</span>;</span><br><span class="line">       <span class="meta"># <span class="keyword">endif</span>        </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为了防止重复编译，一些头文件开始会有<code> pragma once</code>的字样</p></blockquote><h3 id="格式化输入输出函数："><a href="#格式化输入输出函数：" class="headerlink" title="格式化输入输出函数："></a>格式化输入输出函数：</h3><p>格式化输入和输出分别是scanf（）和printf（）函数，其中%所表示的数据类型和格式，可以通过例如  %12.3f  限制输入输出的格式是总共12位、小数点后3位的浮点数。另外还有%g用于舍弃无意义零等，可以自行查阅。</p><p>在上示代码中的<strong>输出</strong>部分，双引号里面输出的有普通的字符和转义字符以及用%占位的变量，变量需要对应且格式正确。</p><p>而输入部分需要严格按照引号内容，输入，包含可能的逗号和空格。最重要的是变量前需要有**&amp;** 符号。输入完成或者需要输入下一个数据需要按空格、回车或者tab。当输入非法字符或者明显一个字符输入完的时候，程序开始下一个数据的输入，比如整数和字符串一起输入。但是用%c数输入单个字符时，空格和转义字符都算有效字符，故一般使用getchar（），如ch&#x3D;getchar（）。</p><blockquote><p>除了x,e,g用大小写都可以（大写时输出数据也要大写），其他的格式都要用小写。</p><p><code>%*</code>是scanf的赋值抑制字符，将原本读出的数据舍弃,比如%*2d是舍弃对应的两位整数</p><p>如果上一次输入的最后一个字符是回车键，可能回车会一直保留导致下一次对字符的输入失效，可以用getchar（）来吞回车</p></blockquote><p>推荐使用c++的输入输出方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot; a =&quot;</span>&lt;&lt; a &lt;&lt;endl;<span class="comment">//endl是回车的意思</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数之间相互独立，可以相互调用，自己调用自己即递归。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 返回类型 函数名 （形参）</span><br><span class="line">    形参说明（一般不在这）;</span><br><span class="line">&#123;</span><br><span class="line">    变量定义；</span><br><span class="line">    语句；</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> x;<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;y?x:y; <span class="comment">//三目运算符，表示判断为真则表达式值为x，反之为y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数在定义的时候参数是形参，只有在运行函数的时候会分配空间，运行完释放。实参是调用函数的时候，实参对形参的值的传递是单向的，一些改变原本实参的函数不能通过简单的调用实现，需要依靠指针，或者数组的传递本身也是地址传递，会影响到实参。具体的在指针部分介绍。</p><blockquote><p>指针的作用之一就在这里，如果单纯传递某个变量的值的话，那么操作对象就是这个值，和变量无关，但是如果你把变量存储的地址发送过去了，那么操作对象就可以直接变成变量的老家。</p><p>数组就是传递了起始数据的地址比如<code>int max(int num[],int n)//n表示数组大小</code>，如果是多维数组的传递的话，必须要把列数说明，比如<code>  int max(int num[ ][4])</code></p></blockquote><p>return expression; 返回对应数据，如果void则不返回，但是可以通过 return ;语句提前结束函数</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是同一数据类型的集合，数组定义的时候必须要输入具体多少个数据和这些数据的类型，在c语言中不可以定义动态数组，即数组中元素的个数是常量。</p><p>在内存中数组是偏移量（下标）为0开始的一系列存储单元，要保证调用的时候不能越界。</p><p>数据处理的对象只能是一个元素，不能是一整个数组（初始化除外）。</p><p>多维数组可以看成一个递归的定义，比如二维数组是一维数组的数组，三维数组是二维数组的数组。在物理存储位置中，c语言是从低地址到高地址按行存储，先存第一行即 <code>a[0][0],a[0][1],a[0][2],a[1][0]...</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*数组的初始化*/</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;<span class="comment">//定义的时候初始化，不能超过值，少于的话一般剩下的会自动变0，取决于编译器</span></span><br><span class="line"><span class="type">int</span> num[]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;<span class="comment">//和上面等价，表示全部内容</span></span><br><span class="line"><span class="comment">/*多维数组*/</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">2</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;&#125;;<span class="comment">//按照行来初始化</span></span><br><span class="line"><span class="comment">/*字符数组与字符串*/</span></span><br><span class="line"><span class="comment">//字符数组用于处理的就是字符串，一般用一二维的数组</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>]=<span class="string">&quot;clanguage&quot;</span>;<span class="comment">//如果有剩余的都初始化为&#x27;\0&#x27;</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">3</span>]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> str[<span class="number">2</span>][<span class="number">5</span>]=&#123;<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>和字符串相关的函数有 <code>gets();puts();strcmp();strcpy();strcat();strlen();</code>等，可以查阅&lt;string.h&gt;</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针是c的很重要的一部分，可以看作一个存储地址的变量。指针的存在使得代码难度上升，更容易崩电脑，也让代码紧凑高效。由于它自己就是个地址，也可以看成一个箭头，箭头指向的是地址对应的变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针定义</span></span><br><span class="line"><span class="type">int</span> *p; <span class="comment">//和其他的变量不同，这里的int* 表示指向的数据的类型</span></span><br><span class="line"><span class="type">int</span> i,*p=&amp;i;<span class="comment">//这里在定义变量的同时给p赋值了，就是i的地址。 &amp;运算符是求地址。而*p==i</span></span><br><span class="line"><span class="comment">//指针的存在像是揭发了变量的老窝，把函数的能力从你给我什么我改变什么变成你给我地址 我到它家去改变它</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x,<span class="type">int</span> *y)</span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t=*x;*x=*y;*y=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> a=<span class="number">2</span>,b=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> *pa=&amp;a,*pb=&amp;b;</span><br><span class="line">swap(pa,pb);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指针的运算加减，可以看成是箭头的移动</span></span><br></pre></td></tr></table></figure><p><strong>指针和数组之间的关系</strong>：</p><p>数组名表示的是数组首地址，不能修改，故数组的访问也可以通过指针实现，但一般能用下标解决就不用那么麻烦了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">10</span>],*p=a;</span><br><span class="line">p==&amp;a[<span class="number">0</span>];<span class="comment">//为真</span></span><br><span class="line">p[<span class="number">1</span>]==a[<span class="number">1</span>]; <span class="comment">//数组的括号中是指偏移量，为0则和首地址是一样的没有偏移</span></span><br><span class="line">*p++ 等价于 a[i++] <span class="comment">//p=a+i为前提，这里是指参与表达式或者函数参数传递的是*p然后再下一轮循环或者其他的调用中+1</span></span><br><span class="line">*++p 等价于 a[++i]</span><br><span class="line"><span class="comment">/*利用指针实现数组元素的读取:*/</span></span><br><span class="line"><span class="type">int</span> i,a[<span class="number">10</span>],p=a;</span><br><span class="line"><span class="keyword">while</span>(p&lt;a+<span class="number">10</span>)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,p++);<span class="comment">//通过指针的移动写入数组所在地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>作为函数参数传递的时候指针和数组名是等价的，因为本质上传递的都是地址</p></blockquote><p><strong>二维数组的指针</strong>：</p><p>二维数组的指针可以看成一个指针在对应的存储单元移动，即先按行移动，或者可以看成每一行都是一个数组，此时表示方法也发生了一些变化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*指向数组的指针 / 行指针 */</span></span><br><span class="line"><span class="type">char</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="type">char</span>(*p)[<span class="number">4</span>];<span class="comment">//可以理解为指向的数据类型是char[4]的数组,故此时也称p为行指针</span></span><br><span class="line">p==a; </span><br><span class="line">p[i]==a[i];p[i]==*(p+i);<span class="comment">//表示第i行的数组，那么此时又可以把p[i]看成这一行数组的首地址，也就是数组名</span></span><br><span class="line">p[i][j]==a[i][j];p[i][j]=*(*(p+i)+j);</span><br><span class="line"><span class="comment">/*也可以沿用一维数组指向元素的方式*/</span></span><br><span class="line"><span class="type">char</span> *p=a;</span><br><span class="line">p[m*<span class="number">3</span>+n]==a[m][n];</span><br></pre></td></tr></table></figure><p>对于字符串，可以使用之前指向数组的指针的方式，也可以直接将字符串常量本身的地址赋给指针变量。另外不同的字符串常量哪怕内容相同，在存储器中也会有不同的存储空间</p><blockquote><p>需要注意的是，在定义指针变量的时候分配的只有一个地址的空间，但是并没有对指向的数据进行分配空间，这一点和数组是完全不同的，数组是建房存数据的地方，指针只是一个箭头用于指向某块地址，所以在后面可能会介绍malloc函数或者new函数，这些都是为数组指向的数据分配空间的函数。</p></blockquote><p><strong>指向函数的指针</strong>：函数的入口地址就是函数的指针，但是一般不会用，有一个比较有用的应用比如一元函数定积分的求解，将函数作为另外一个函数的参数，此时利用指针就是一个很好的选择。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">integral</span><span class="params">(<span class="type">double</span>(*f)(<span class="type">double</span>),<span class="type">double</span> a,<span class="type">double</span> b)</span><span class="comment">//函数的指针需要声明函数类型和参数类型</span></span><br><span class="line">&#123;<span class="comment">//函数指针f可以用函数名赋值，比如f=max</span></span><br><span class="line"> <span class="comment">/*这里使用的是定积分的梯形法求解*/</span></span><br><span class="line">    <span class="type">double</span> s,h;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">100</span>,i;</span><br><span class="line">    h=(b-a)/n;<span class="comment">//表示分割宽度</span></span><br><span class="line">    s=((*f)(a)+(*f)(b))/<span class="number">2.0</span>;<span class="comment">//边界</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)  s+=(*f)(a+i*h);<span class="comment">//其余梯形的上底加下底乘高除以二但是相邻的梯形乘二</span></span><br><span class="line">    <span class="keyword">return</span> s*h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*函数的返回值为指针类型*/</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">foo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;<span class="comment">//声明指针变量为： int (*foo)(int x,int y);</span></span><br></pre></td></tr></table></figure><p><strong>指针数组和指向指针的指针</strong>：</p><p>指针数组和指向数组的指针的区别从名称可以看出来，这里就是一系列指针的意思。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * p[<span class="number">4</span>];<span class="comment">//指针数组</span></span><br><span class="line"><span class="type">char</span> (*p)[<span class="number">4</span>];<span class="comment">//指向数组的指针，行指针</span></span><br><span class="line"><span class="type">char</span> **p;<span class="comment">//指向指针的指针</span></span><br><span class="line"><span class="comment">/*指针数组的应用，比如字符串数组*/</span></span><br><span class="line"><span class="type">char</span> *name[]=&#123;<span class="string">&quot;alice&quot;</span>,<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;jerry&quot;</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复杂的声明</strong>：有时候太复杂也不好，注意*是自右向左结合的，可以用typerdef将复杂的声明用小步骤代替。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>(*(*x[<span class="number">3</span>])())[<span class="number">5</span>];</span><br><span class="line"><span class="comment">//最中间的*x[3]表示的是指针数组，然后括号括起来，后面也有个括号，这是函数指针的声明，意思是指针数组中的指针指向的是函数。函数声明会有返回值的声明，也就是前面的 char* ，意思是函数的返回值是指向char类型的指针，这个指针是个字符串的行指针。</span></span><br><span class="line"><span class="comment">//可以拆成 char[*(*x[3])()] 和 char *p[5];</span></span><br><span class="line"><span class="comment">//英文解释： x is an array[3] of pointer to function returning pointer to array[5] of char</span></span><br></pre></td></tr></table></figure><p><strong>命令行参数</strong>：补充说明命令行的一些内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span>;</span><br><span class="line"><span class="comment">//前面是命令行参数的个数和命令行参数字符串数组，另外命令行参数包括文件名本身</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(--argc&gt;<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%s%c&quot;</span>,*++argv,(argc&gt;<span class="number">1</span>)? <span class="string">&#x27;&#x27;:&#x27;</span>\n<span class="number">&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//argv[0]是程序名称，没有参数的时候argc是1</span></span><br><span class="line"><span class="comment">//这是在使用命令行的时候添加的命名，在vs中也有设置的内容</span></span><br></pre></td></tr></table></figure><blockquote><p>void类型的指针是指，一个指针不指定数据，可能作为函数形参或者返回值类型</p></blockquote><h3 id="文件的输入输出"><a href="#文件的输入输出" class="headerlink" title="文件的输入输出"></a>文件的输入输出</h3><p>c语言对文件的存取以字节为单位，文件操作都是FILE 类型指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件打开</span></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">char</span> *filename,<span class="type">char</span> * mode)</span>; <span class="comment">/*现在很多编译器要求安全打开方式*/</span></span><br><span class="line"><span class="comment">//一般mode有 只读 r 只写 w 等</span></span><br><span class="line"><span class="comment">//文件关闭</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/A-624/blog_img/image-20220730123445712.png" alt="image-20220730123445712" style="zoom:67%;" /><p>关于文件的读写的常用函数有：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>int fputc(int c,FILE *fp) ;</td><td>输出字符</td></tr><tr><td>int fgetc(FILE *fp) ;</td><td>输入字符</td></tr><tr><td>size_t fwrite(void *buffer,size_t size,size_t count,FILE *fp);</td><td>输出数据块</td></tr><tr><td>size_t fread(void *buffer,size_t size,size_t count,FILE *fp);</td><td>输入数据块</td></tr><tr><td>int fprintf(FILE *fp,char *format[,address,…]);</td><td>格式化输出</td></tr><tr><td>int fscanf(FILE *fp,char *format[,address,…]);</td><td>格式化输入</td></tr><tr><td>int feof(FILE *fp);</td><td>检测文件是否结束，尚未结束则返回0</td></tr><tr><td>void rewind(FILE *fp)</td><td>文件指针返回开头</td></tr><tr><td>int fseek(FILE *fp, long offset,int whence)</td><td>文件指针跳转</td></tr><tr><td>long ftell(FILE *fp)</td><td>成功则返回文件指针位置，出错返回-1</td></tr></tbody></table><blockquote><p>fseek 的 快捷定位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp,<span class="number">100L</span>,SEEK_SET);fseek(fp,<span class="number">100L</span>,<span class="number">0</span>);<span class="comment">//文件开始位置</span></span><br><span class="line">fseek(fp,<span class="number">100L</span>,SEEK_CUR);fseek(fp,<span class="number">100L</span>,<span class="number">1</span>);<span class="comment">//当前位置</span></span><br><span class="line">fseek(fp,<span class="number">100L</span>,SEEK_END);fseek(fp,<span class="number">100L</span>,<span class="number">2</span>);<span class="comment">//文件末尾</span></span><br></pre></td></tr></table></figure><p>其他的文件读写函数有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其他文件读写函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">char</span> *s ,FILE * fp)</span>;<span class="comment">//字符串写,失败返回EOF</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s ,<span class="type">int</span> n, FILE * fp)</span>;<span class="comment">//字符串读</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">putw</span><span class="params">(<span class="type">int</span> w,FILE *fp)</span>;<span class="comment">//字为单位写</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getw</span><span class="params">(FILE *fp)</span>;<span class="comment">//字为单位读</span></span><br></pre></td></tr></table></figure><p>一般常用且不容易出错的是格式化读写函数，和之前的关系类似，只需要加一个文件指针即可</p></blockquote><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体是自己定义的一个复杂类型，可以包括很多基础的数据类型，在数据结构部分会对链表进行进一步的介绍</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;变量<span class="number">1</span>;<span class="comment">//可以在声明的时候定义变量</span></span><br><span class="line"><span class="comment">//成员也可以是结构体，但是不能递归嵌套，不能为空</span></span><br><span class="line"><span class="comment">/*初始化*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>=</span>&#123;</span><br><span class="line">    <span class="number">12</span>;</span><br><span class="line">    <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">age=stu.age;<span class="comment">//调用成员</span></span><br><span class="line"><span class="comment">//结构体变量可以整体相互赋值，也有结构体数组等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*指向结构体的指针*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>,*<span class="title">p</span>=</span>&amp;stu;</span><br><span class="line">p-&gt;age;<span class="comment">//指向的结构体的成员，和stu.age一个意思</span></span><br></pre></td></tr></table></figure><p>另外可以使用typedef来定义类型别名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    chae name[<span class="number">10</span>];</span><br><span class="line">&#125;stu,*sp;</span><br><span class="line"><span class="comment">//这里以后声明变量可以直接用 stu a; 而不是struct student a;指针类型也是 sp point;即可</span></span><br></pre></td></tr></table></figure><p>动态存储分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">p=<span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(stu));<span class="comment">//这里是先计算结构体的存储空间，分配之后将地址返回给p</span></span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//释放空间</span></span><br></pre></td></tr></table></figure><h3 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h3><p>位运算速度快，效率高，节省存储空间，负数以补码形式参与运算，只能对整型数据进行运算，且这里运算的都是二进制，不过对于十六进制的位运算也很有用，另外需要注明的是，进制只是一个形式，数的本质是不变的，这一点曾经在python学习中困扰我很久，对于py的进制转化和一些数据的计算可能会在有关博客中记录</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&amp; 按位与 类似于二进制乘法 主要作用是按位清零或者保留，比如十六进制保留最后四位二进制数</span></span><br><span class="line"><span class="number">0</span>x <span class="number">1232</span> <span class="number">2341</span> &amp; <span class="number">0xf</span>==<span class="number">0</span>x <span class="number">1</span></span><br><span class="line"><span class="comment">// | 按位或 类似于二进制加法，有1则结果为 1 </span></span><br><span class="line"><span class="comment">// ^  按位异或 类似于二进制无进位加法， 1^1=0 也可以按照名称理解相同为0 不同为1</span></span><br><span class="line"><span class="comment">//~ 按位取反 不常见</span></span><br></pre></td></tr></table></figure><p>异或可以用来交换两个整数值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=a^b;</span><br><span class="line">b=b^a;<span class="comment">//这一步相当于 b^a^b,那么结果就是原本的 a</span></span><br><span class="line">a=a^b;<span class="comment">//b 现在是原本的 a 那么a^b^a就相当于原本的 b</span></span><br></pre></td></tr></table></figure><p>左移和右移看作乘法和除法即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i&lt;&lt;n ;<span class="comment">//左移 * 2 ^ n 如果有位数限制可能会溢出</span></span><br><span class="line">i&gt;&gt;n;<span class="comment">//右移 / 2 ^ n 去掉小数部分，这个其实也取高位进制的作用</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>x <span class="number">1234</span> <span class="number">5678</span> &gt;&gt;<span class="number">4</span> == <span class="number">0</span>x <span class="number">123</span> <span class="number">4567</span> <span class="comment">//相当于除以十六</span></span><br><span class="line"> <span class="comment">//符号扩展，正数前面用0填充，负数用1 填充</span></span><br></pre></td></tr></table></figure><blockquote><p>最后以一段很喜欢的文字收尾</p><p>我希望有个如你一般的人</p><p>如山间清爽的风，如古城温暖的光</p><p>从清晨到夜晚，从山野到书房</p><p>等待</p><p>不怕岁月蹉跎，不怕路途遥远</p><p>只要最后</p><p>是你就好y</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web 学习记录</title>
      <link href="/2022/07/14/web%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/"/>
      <url>/2022/07/14/web%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-web方向入门记录"><a href="#CTF-web方向入门记录" class="headerlink" title="CTF web方向入门记录"></a>CTF web方向入门记录</h1><blockquote><p>本条记录web安全学习的入门内容，前期准备工作有burp suite的下载，pikachu靶场的搭建等，按照学习的路线进行记录，如有错误，还望指正。</p></blockquote><span id="more"></span><h2 id="密码爆破"><a href="#密码爆破" class="headerlink" title="密码爆破"></a>密码爆破</h2><h3 id="基于表单的暴力破解"><a href="#基于表单的暴力破解" class="headerlink" title="基于表单的暴力破解"></a>基于表单的暴力破解</h3><p>使用火狐浏览器搭建pikachu靶场后进行bp抓包，使用表单进行暴力破解，现实生活中对于暴力破解会有更多限制比如登录错误次数等。这里打开靶场点击基于表单的暴力破解，随便输入账号密码提交后使用bp监听抓包。</p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220716112109247.png" style="zoom:70%;/" /><p>然后点击action点击发送到intruder进行爆破</p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220716112204041.png" style="zoom:67%;" /><p>在intruder页面中可以进行爆破对象的选择，先点击clear然后在爆破位置重新add。</p><blockquote><p>其中攻击类型一栏有： </p><p>Sniper: 单变量设置一个payload攻击；</p><p>Battering ram: 设置两个变量，一个payload； </p><p>Pitchfork: 可以同时替换n个变量。不同个payload的值与变量一一对应。 （按照顺序对应，基本不用）</p><p>Cluster bomb: 可以同时替换n个变量。分别设置payload然后交叉破解。（一般使用）</p></blockquote><p>然后在payload页面里面导入字典，或者使用自带的字典，设置后点击start attack，通常暴力破解需要很长的时间，这里我们直接输入包含正确答案的几个选项简化过程</p><blockquote><p>一般我们会使用runtime file然后导入我们自己的字典</p></blockquote><p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220716113120840.png" alt="image-20220716113120840"></p><p>最后的结果可以看到在length一栏里正确答案会不同</p><p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220716113443853.png" alt="image-20220716113443853"></p><p>输入后成功</p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220716113626168.png" alt="image-20220716113626168" style="zoom:67%;" /><h3 id="验证码绕过（on-server）"><a href="#验证码绕过（on-server）" class="headerlink" title="验证码绕过（on server）"></a>验证码绕过（on server）</h3><p>为了防止暴力破解而产生的验证码可能因为长期不更新或者存在规律而无法生效，这里考虑的是验证码的持续有效性，比如php默认session中的验证码在24min内有效。</p><p>先确认验证码是否在服务器端存储不过期，方式就是send to repeater进行重放观察返回数据，重放的时候使用不同账号密码，如果仅显示账户密码错误而不是验证码错误那么说明验证码是在有效期内。</p><blockquote><p>反思：防止攻击的话考虑更改php.in设置验证码的过期时间。或者由于验证码是会发送给session的，考虑验证过一次之后直接销毁session。</p></blockquote><p><strong>验证码绕过(on client)</strong></p><p>在客户端的验证在失败之后会重新生成验证码，需要考虑这一类验证码的漏洞。</p><img src="https://pic3.zhimg.com/80/v2-3cfd6cf0b9b6bfaedb9347bb5ba523b7_720w.png?source=d16d100b" alt="img" style="zoom:67%;" /><p>客户端验证码常见问题有</p><ul><li><p>使用前端js实现验证码（本题），使逻辑暴露在客户端存在安全问题。</p></li><li><p>将验证码在cookie中泄露</p></li><li><p>验证码在前端源代码中泄露</p></li></ul><p>所以我们需要查看的就是验证码是不是在前端生成并且确认，查看源码可以发现确实，那么数据包直接绕过前端的验证码发送给服务器也没有问题，故直接按照之前的步骤爆破，（爆破过程中服务器并不会检查验证码是否错误）。</p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220717002058406.png" alt="image-20220717002058406" style="zoom: 67%;" /><p>···</p><p><strong>token防爆破？</strong></p><img src="https://picx.zhimg.com/80/v2-99a057b68f9108c06dab5f47e893dd83_720w.png?source=d16d100b" alt="img" style="zoom:67%;" /><p>token是<strong>服务器</strong>生成的一个字符串作为客户端请求的标识，在新登录的时候需要提交正确的token值。本题中下一次登录的token在上一次的服务器返回包里，故单线程进行。</p><blockquote><p>简单token的组成：uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串。为防止token泄露）。</p><p>token验证的基本机制：<br>1、当客户端第一次请求时，发送用户信息至服务器(用户名、密码)，服务器对用户信息签名，再将这个签名和数据一起作为Token一起返回给客户端。<br>2、服务器不保存Token，客户端保存Token(比如放在 Cookie 里或者 Local Storage 里)<br>3、当客户端再次发送请求时，在请求信息中将Token一起发给服务器<br>4、服务器用同样的HS256算法等，对数据再进行一次签名，和客户端返回的Token的签名进行比较，如果验证成功，就向客户端返回请求的数据</p></blockquote><p>token是无法防止暴力破解的，所以这一次我们加上对token的爆破，即我们把抓包内容发送到intruder中，然后在grep-extract中添加过滤条件——token值。</p><p>首先是抓包的数据，发现随机生成的token值</p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220716154700436.png" alt="image-20220716154700436" style="zoom:67%;" /><p>把option中的线程设置为一，这是因为token的变化性，不允许程序的并发运行。另外由于token储存在html包的body的hidden部分，所以要把redirection（重定向）选择always然后便可以达到绕过token经行破解的目的。</p><p><img src="https://pica.zhimg.com/80/v2-939e7c5bc8cb29c4dcc6cd73638da849_720w.png?source=d16d100b" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-b2326ca5bbc6fcfe54a33faf3c34c1b1_720w.png?source=d16d100b" alt="img"></p><p>在grep-extract中找到token的值，这里直接搜索在字段 value&#x3D;“后面的内容，点击refetch response会跳转到含有token的页码。然后点击正确的token值。</p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220716155800506.png" style="zoom:67%;" /><p>在payload设置中，前面的集合正常设置，token集合的payload类型更改为递归攻击 recursive grep</p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220716160612598.png" alt="image-20220716160612598" style="zoom:67%;" /><p>然后把初始的token值传入：</p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220716175252529.png" alt="image-20220716175252529" style="zoom:67%;" /><p>开始攻击后发现有一个成功爆破。</p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220717004451945.png" alt="image-20220717004451945" style="zoom:67%;" /><h2 id="XSS跨站脚本攻击（Cross-Site-Scripting）"><a href="#XSS跨站脚本攻击（Cross-Site-Scripting）" class="headerlink" title="XSS跨站脚本攻击（Cross Site Scripting）"></a><strong>XSS跨站脚本攻击（</strong>Cross Site Scripting）</h2><p>恶意攻击者往 WEB 页面里插入恶意 HTML 代码，当用户浏览该页之时，嵌入其中 Web 里面的 HTML 代码会被执行，从而达到恶意攻击用户的特殊目的。主要发生在前端，危害较大。主要是对输入输出的内容没有进行处理。</p><blockquote><p>1.反射型XSS：交互的数据不存数据库而是所见即所得，一般出现在查询页面</p><p>2.存储型XSS：永久存储在数据库中，比如留言板、注册页面</p><p>3.DOM型XSS：不与后台服务器进行数据交互，通过DOM操作前端代码，属于反射型</p><p>实际攻击中可能有用户访问xss页面触发攻击脚本，执行后窃取用户的数据发送给攻击者的服务器，然后攻击者利用这个数据发送给站点进行用户的伪造。</p><p>xss的漏洞测试流程：找到查询点留言板等，之后输入特殊字符和唯一识别的字符，然后提交查看是否有返回的源码，如果基本上没有什么安全措施的话可构造闭合的payload。</p></blockquote><p>而在靶场中我们测试的目标就是检测相应的xss漏洞。步骤大概是在网站的交互输入观察页面是否会对内容进行转义，然后通过源码来查看是否有构造闭合的条件，提交相应的脚本代码然后执行观测结果，执行成功说明有相应的xss漏洞。</p><p>首先需要了解js的一些内容，不同浏览器也会集成不同的js解释引擎，这里使用的是火狐的spidermonkey。</p><p>嵌入在 HTML 中的 JS 代码通常有以下几种形式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">直接插入代码块</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">加载外部 JS 文件</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;test.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">使用 HTML 标签中的事件属性</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(&#x27;Hello&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>js的数据类型</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过“ <span class="keyword">new</span> ”来声明变量类型：</span><br><span class="line"><span class="keyword">var</span> pi=<span class="keyword">new</span> <span class="title class_">String</span>;#字符串</span><br><span class="line"><span class="keyword">var</span> pi=<span class="keyword">new</span> <span class="title class_">Number</span>;#数字</span><br><span class="line"><span class="keyword">var</span> pi=<span class="keyword">new</span> <span class="title class_">Boolean</span>;#布尔值</span><br><span class="line"><span class="keyword">var</span> pi=<span class="keyword">new</span> <span class="title class_">Array</span>;#数组</span><br><span class="line"><span class="keyword">var</span> pi=<span class="keyword">new</span> <span class="title class_">Object</span>;#对象</span><br></pre></td></tr></table></figure><p>赋值不需要指定类型:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pi=<span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">var</span> pi=<span class="string">&#x27;ratio of the circumference of a circle to its diameter&#x27;</span>;</span><br></pre></td></tr></table></figure><p>Undefined 和 Null:</p><p>简单区分，前者为有对象没有值，后者为没有对象。</p><p>所有的JS变量都是对象但是对象声明的字符喜欢和直接赋值的字符串并不严格相等。</p><p><strong>JavaScript 编程逻辑</strong></p><p>if 条件语句：switch 条件语句：for&#x2F;for in 循环语句：while&#x2F;do while 循环语句：和一般的编程语言（c）类似</p><p><strong>JavaScript 打印数据</strong></p><ul><li><strong>window.alert()弹出警告框</strong></li><li><strong>document.write()写入HTML文档</strong></li><li><strong>console.log()写入浏览器控制台</strong></li></ul><h3 id="反射型xss-get"><a href="#反射型xss-get" class="headerlink" title="反射型xss(get)"></a><strong>反射型xss(get)</strong></h3><img src="https://pic3.zhimg.com/80/v2-7843c673c06d3c0db826e88d2d8b4c61_720w.png?source=d16d100b" alt="img" style="zoom:67%;" /><p>我们查看源码，发现有关设置是直接输入，所用方式为get。，</p><p><img src="https://pica.zhimg.com/80/v2-68a5095b7976b60da44056fe4432745e_720w.png?source=d16d100b" alt="img"></p><ul><li><p>**<script> 标签:**用于定义客户端脚本，比如 JavaScript</p></li><li><p>**<div>标签:**用于组合块元素,定义文档中的一个标签部分或者一个区域部分。</p></li><li><p>:定义一个段落</li><li><!--...-->：注释</li><li><form> ：创建供用户**输入**的 HTML 表单。</li></ul><p>这样我们大概可以了解这些语句的目的了。由于这里所用的方式是get，我们直接在url中插入有关脚本。</p><p><img src="https://pic2.zhimg.com/80/v2-6f25e1cd0a2b143097a27243d0dfdafe_720w.png?source=d16d100b" alt="img"></p><img src="https://pic2.zhimg.com/80/v2-4fabedec0b859f792716759d7c9a3a29_720w.png?source=d16d100b" alt="img" style="zoom:50%;" /><p>如果是在输入框中输入的话会有字数限制，其实正常的步骤就是先在输入框中输入特殊字符然后看前端的处理，这里我们可以打开源码，搜索到输入内容。</p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220717120613958.png" alt="image-20220717120613958" style="zoom:67%;" /><p>可以看到这里并没有对输入内容进行处理，但是展开上面的输入内容发现在输入框中限制了字数，这种在前端的辅助安全措施并不能有效抵御攻击，直接找到设定长度的代码然后修改，再输入闭合语句。</p><img src="https://raw.githubusercontent.com/A-624/blog_img/master/image-20220717120823592.png" alt="image-20220717120823592" style="zoom: 50%;" /><blockquote><p>这里可以看出由于后端没有对输入的内容进行处理，故存在这个漏洞，由于是反射型的xss，刷新之后对系统也没啥影响了，但是通过url的输入可以达到弹窗或者其他的js功能。另外这个长度的限制也可以使用bp抓包后修改，这个和get方式有关。</p><p>实际中的攻击是通过发送给别人一串带有xss（get）的url发送给目标执行之后，直接对服务器执行一个恶意的脚本。</p></blockquote><p><strong>反射性xss(post)</strong></p><p><img src="https://pic2.zhimg.com/80/v2-8e9775a829e31212ca58f6a469048ff1_720w.png?source=d16d100b" alt="img"></p><p>按照提示登陆后在框框里输入我们之前输入的那个脚本。</p><p><img src="https://pic4.zhimg.com/80/v2-780017aeffe613e52e6d8f1d6531a544_720w.png?source=d16d100b" alt="img"></p><blockquote><p>反射性xss一般在查询接口 由于后台可能存在过滤措施所以构造的script可能会被过滤掉，可以尝试不同的script来绕开后台的过滤机制。</p></blockquote><p>post类型的xss的攻击场景是 bob在正常访问页面的时候访问了恶意服务器的表单页面，恶意服务器发送自动post的恶意代码后被bob post到了正常的服务器上。</p><p><strong>存储型xss</strong></p><blockquote><p>存储型XSS和反射型XSS形成的原因是一样的，不同的是存储型XSS下攻击者的可以将脚本注入到后台存储起来，构成更加持久的危害</p></blockquote><p><img src="https://pica.zhimg.com/80/v2-25867e4bb06116d704a01fd65b4c5a41_720w.png?source=d16d100b" alt="img"></p><p>我们在留言板中输入相同的payload，出现相同结果，但是值得注意的是。检测成功后我们不输入内容点击提交，出现以下界面。</p><p><img src="https://pic2.zhimg.com/80/v2-2d61b4a399d32b8cac9c317ab8b0d35f_720w.png?source=d16d100b" alt="img"></p><p>这说明我们的payload已经被储存在数据库中，不被删除则被一直执行。这里的漏洞其实考虑了sql的注入但是没有对输出的数据进行处理。</p><p><strong>DOM型xss</strong></p><blockquote><p>dom  把html的标签看成dom树，即提供了文档的结构化描述。并且定义了方法可以从程序中对结构进行访问。</p></blockquote><p>之前的payload并没有成功，我们先查看一下网页的源代码</p><p><img src="https://pica.zhimg.com/80/v2-0aa0695cef7706519e06c8dbd3e99414_720w.png?source=d16d100b" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-8c7abf47288cca9da1ec0a4642ca26f4_720w.png?source=d16d100b" alt="img"></p><p>找到有关输入的部分，看到网页自己定义了一个domxss的函数，我们找一下相关的定义（上搜索栏）。</p><p><img src="https://pic3.zhimg.com/80/v2-bdeeabab879e01998978baa94edd802b_720w.png?source=d16d100b" alt="img"></p><p>这里的domxss的函数是通过dom将text节点的值作为变量赋给了dom节点，所以我们输入的内容会被赋到dom上，这里提示闭合(闭合的是a herf标签)。</p><p>如果输入'><img src="#" οnerrοr=alert(/xss/)" >或者'><img src="#" onmouseover=alert(/xss/)" >图片不存在则加载错误，弹框。</p><blockquote><p>onmouseover 事件：鼠标指针移动到图片后执行Javascript代码                                                <strong>onerror</strong>事件：一种老式的标准的在网页中捕获Javascript 错误的方法，它在加载外部文件（文档或图像）发生错误时被触发</p></blockquote><p><img src="https://pica.zhimg.com/80/v2-4ef6ab0cfe5f78ac7430bc1559111410_720w.png?source=d16d100b" alt="img"></p><p>观察一下代码</p><p><img src="https://pic2.zhimg.com/80/v2-8c7abf47288cca9da1ec0a4642ca26f4_720w.png?source=d16d100b" alt="img"></p><p><img src="https://pica.zhimg.com/80/v2-ce2ae3d936febb01871355767510aadf_720w.png?source=d16d100b" alt="img"></p><blockquote><p>至于为什么输入的是单引号不是双引号，不知且确实不行</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入&#x27; onclick=&quot;alert(/xss/)&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="https://pica.zhimg.com/80/v2-66a62bac80e697a22237f1e18eb68701_720w.png?source=d16d100b" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-39d79b43de5af3075216a4568beb0d1b_720w.png?source=d16d100b" alt="img"></p><p>在这里我们使用了超链接，观察一下代码</p><p><img src="https://pic2.zhimg.com/80/v2-4e458123cc15c43949eeb4855853e773_720w.png?source=d16d100b" alt="img"></p><p>这是在点超链接之前：</p><p><img src="https://pic2.zhimg.com/80/v2-24216c97428567f05881dabca0f64980_720w.png?source=d16d100b" alt="img"></p><p>在点击之后事件消失。相当于a herf实现了一个超链接的内容。</p><p><strong>DOM型xss-x</strong></p><p><img src="https://pic1.zhimg.com/80/v2-8971e10548d5fe2a63a46aa19ab1638b_720w.png?source=d16d100b" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-4f32ee196c54ad9d225bb5a2f149803f_720w.png?source=d16d100b" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-0769e65f87f9ec0517422029d8c04d3d_720w.png?source=d16d100b" alt="img"></p><p>盲打即不前端显示，进入后台（提示的地址修改url）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入&lt;script&gt;alert(/xss/)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://pic3.zhimg.com/80/v2-dacee5041c943b80fb4cdab0311c19b3_720w.png?source=d16d100b" alt="img"></p><p><strong>xss之过滤</strong></p><p><img src="https://pic2.zhimg.com/80/v2-cb8a4f3b886ca6c897328f687e0309e1_720w.png?source=d16d100b" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入&lt;script&gt;alert(/xss/)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>发现被过滤，按照之前说的，修改大小写</p><blockquote><p>常用方法也有使用注释如<scri pt>alert（/xss/）</scri pt></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入&lt;SCript&gt;alert(/xss/)&lt;/SCript&gt;</span><br></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/80/v2-c7078620519cbe3ee1a68ee21914fb09_720w.png?source=d16d100b" alt="img"></p><p><strong>xss之htmlspecialchars</strong></p><p><img src="https://pic1.zhimg.com/80/v2-ea7594e633b7c2bb975acd9cead11a8f_720w.png?source=d16d100b" alt="img"></p><blockquote><p>htmlspecialchars:对一些符号编码成HTML编码防止注入。 预定义的字符是 & 成为 &amp " 成为 &quot ' 成为 &#039 < 成为 &lt > 成为 &gt 可用引号类型 ENT_COMPAT：默认，仅编码双引号 ENT_QUOTES：编码双引号和单引号 ENT_NOQUOTES：不编码任何引号</p></blockquote><p>其中有关引号的编码有时候只能编码单引号或者双引号或者不编码任何引号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; onclick=&quot;alert(/xss/)&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="https://pica.zhimg.com/80/v2-19908a2202b4f06486431e29651db254_720w.png?source=d16d100b" alt="img"></p><p><strong>xss之href输出</strong></p><p><img src="https://pica.zhimg.com/80/v2-f7de927758f81d1f394bca07476522f9_720w.png?source=d16d100b" alt="img"></p><p>按照提示我们先查询一下a标签</p><ul><li><a> 标签定义超链接，用于从一张页面链接到另一张页面。</li><li><a> 元素最重要的属性是 href 属性，它指示链接的目标。</li></ul><p>我们这里直接使用js伪协议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascript:alert(/xss/)</span><br></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/80/v2-6a9922ff4d87fc3a3b247df6b06af491_720w.png?source=d16d100b" alt="img"></p><blockquote><p>伪协议不同于ftp http等，是为了关联应用如tencent、data、js js的伪协议，URL的主体为不同的js代码，由js的解释器运行，将最后的字符串作为新文档显示出来。浏览器打开如果URL代码的返回值不是undefined，则前页链接代替返回值。或者仅仅执行动作（alert）。通过void(0)可以生成一个新的空窗口，不显示文档。</p></blockquote><p><strong>xss之js输出</strong></p><p><img src="https://pic3.zhimg.com/80/v2-0c8f8b6770e4e2e0ed1d25752dd5d9b3_720w.png?source=d16d100b" alt="img"></p><p>我们看一下源代码</p><p><img src="https://pic1.zhimg.com/80/v2-141bfdeabb0fb1255c39ea908a7c0063_720w.png?source=d16d100b" alt="img"></p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>跨站请求伪造：一般攻击者会伪造一个请求，欺骗目标用户进行点击。这里并没有直接获得用户的登陆账号密码什么的，而是借助用户自己的权限实现攻击。</p><p>举例来说如果一个网站的用户密码的更改方式是点击一个包含更改信息的URL链接，那我们可以伪造一个类似的链接，并且祈祷被攻击者刚好在登陆该网站之后点击了我们的链接，从而达到改他密码的目的。</p><p>一般网页对应的预防措施有：</p><ul><li>对敏感信息的操作增加安全的token；</li><li>对敏感信息的操作增加安全的验证码；</li><li>对敏感信息的操作实施安全的逻辑流程，比如修改密码时，需要先校验旧密码等。</li></ul><p><strong>CSRF(get) login</strong></p><p><img src="https://pic3.zhimg.com/80/v2-95d3f106c59c587b899c9f694ff05f61_720w.png?source=d16d100b" alt="img"></p><p>按照提示登陆一个账号</p><p><img src="https://pic4.zhimg.com/80/v2-8293d46b02b82bc4368caa4e95af4a9a_720w.png?source=d16d100b" alt="img"></p><p>修改个人信息，然后老规矩用burpsuite抓包</p><p><img src="https://pic1.zhimg.com/80/v2-c9c5c4c3b1963009343bf13ee5c38b8d_720w.png?source=d16d100b" alt="img"></p><p>可以看到第一行：</p><p>GET /pikachu-master/pikachu-master/vul/csrf/csrfget/csrf_get_edit.php?sex=gril&phonenum=11111111&add=aaa&email=aaa%<a href="http://40123.com/">40123.com</a>&submit=submit HTTP/1.1</p><p>我们按照这个格式自己构造一个payload</p><p>GET /pikachu-master/pikachu-master/vul/csrf/csrfget/csrf_get_edit.php?sex=boy&phonenum=222222&add=bbb&email=ccc%<a href="http://40123.com/">40123.com</a>&submit=submit HTTP/1.1</p><p>然后在自己登陆状态下复制访问。</p><p><img src="https://pic1.zhimg.com/80/v2-893910f66a3d180db9e2470fb6af11c4_720w.png?source=d16d100b" alt="img"></p><p>信息修改成功，实际攻击过程就是用抓包或者其他的方法构造这样的链接。</p><p><strong>CSRF(post) login</strong></p><p><img src="https://pic3.zhimg.com/80/v2-de3459b6b97b6b8f1fb9aaa89893c95f_720w.png?source=d16d100b" alt="img"></p><p>按照上面的步骤抓包</p><p><img src="https://pica.zhimg.com/80/v2-f564c34b895fe69a3c2a55aee9741cd2_720w.png?source=d16d100b" alt="img"></p><p>这里我们可以很明显感受得到post要比get要难搞，它不会直接把参数放在url里。这样我们就只能搞一个假的网页了。</p><p>自己写网页比较麻烦，要借助服务器，购买域名然后对网页进行部署。有一个软件叫CRSFtester是可以根据抓包情况自己生成一个恶意的html网页，但是下载比较麻烦，这一题我们暂时掠过，主要思路就是通过构建一个自动修改信息的网页，然后让被攻击者点击这个网页的链接。</p><p><strong>CSRF Token login</strong></p><p>页面和之前一样。</p><p><img src="https://pic3.zhimg.com/80/v2-f61f84d397e3caf7fb7d819c9869ce0e_720w.png?source=d16d100b" alt="img"></p><p>可以看到带的token（随机）使敏感信息没那么容易被篡改。</p><p>由于token值的随机性，攻击无法成功。</p><h2 id="Sql-Inject-SQL注入"><a href="#Sql-Inject-SQL注入" class="headerlink" title="Sql Inject(SQL注入)"></a>Sql Inject(SQL注入)</h2><p>主要形成的原因是在数据交互中，前端的数据传入到后台处理时，没有做严格的判断，导致其传入的“数据”拼接到SQL语句中后，被当作SQL语句的一部分执行。从而导致数据库受损（被脱库、被删除、甚至整个服务器权限沦陷）。</p><p> 在构建代码时，一般会从如下几个方面的策略来防止SQL注入漏洞：</p><p>​                        1.对传进SQL语句里面的变量进行过滤，不允许危险字符传入；</p><p>​                        2.使用参数化（Parameterized Query 或 Parameterized Statement）；</p><p>​                        3.还有就是,目前有很多ORM框架会自动使用参数化解决注入问题,但其也提供                     了"拼接"的方式,所以使用时需要慎重!    </p><p><img src="https://pic1.zhimg.com/80/v2-157426feb0ebbda42abbdc451a423bb6_720w.png?source=d16d100b" alt="img"></p><p>用bp抓包然后send到 repeater中，修改id的值 1 or 1#，点击go，然后查看render</p><p><img src="https://pic1.zhimg.com/80/v2-a2a7f26889cd2a0778cbe6304a048f02_720w.png?source=d16d100b" alt="img"></p><p>所有信息暴露。这里说明有SQL注入。</p><p><strong>字符型注入</strong></p><p><img src="https://picx.zhimg.com/80/v2-425f471ecb6ee71237425d9b2c0bc5a3_720w.png?source=d16d100b" alt="img"></p><p>构造一个回路加一个真语句</p><p><img src="https://picx.zhimg.com/80/v2-108ad0477b95f226df7e4c4c4527dfa4_720w.png?source=d16d100b" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-9b9b02e557b6347ee5dbf6f2a8e84fb9_720w.png?source=d16d100b" alt="img"></p><p><strong>搜索型注入</strong></p><p><img src="https://pic2.zhimg.com/80/v2-ae368484ece3e6aa303bd554921cb8c3_720w.png?source=d16d100b" alt="img"></p><p>搜索型：select username from user where username like '%{$username}%';</p><p>按照提示中的%%</p><p><img src="https://picx.zhimg.com/80/v2-37dfcd56db69bbd3360f2fdd86df4370_720w.png?source=d16d100b" alt="img"></p><p><strong>x</strong></p><p><img src="https://pic1.zhimg.com/80/v2-4d0f36c562fa129f1e48a1e889b676b1_720w.png?source=d16d100b" alt="img"></p><p>不知道什么型：select username from user where username like （‘ ’）;</p><p><img src="https://pic4.zhimg.com/80/v2-c59ab4a171bfe42b8fd205f486f3c317_720w.png?source=d16d100b" alt="img"></p><p>kobe') order by 2## 爆字段列数 </p><p>kobe')union select database(),user()## 爆数据库名和用户名 </p><p>kobe') union select database(),group_concat(table_name) from information_schema.tables where table_schema=database()## 爆数据表 </p><p>kobe') union select database(),group_concat(column_name) from information_schema.columns where table_name='users'## 爆字段 </p><p>kobe') union select database(),group_concat(username,':',password) from users## 爆内容</p><p>总结来说，构造闭合，并且要用#将后面原本正常语句注释掉</p><p><strong>login</strong></p><p><img src="https://pic3.zhimg.com/80/v2-050e14a88c9b4e5c31c92eb91bc61435_720w.png?source=d16d100b" alt="img"></p><h2 id="File-Inclusion-文件包含漏洞"><a href="#File-Inclusion-文件包含漏洞" class="headerlink" title="File Inclusion(文件包含漏洞)"></a>File Inclusion(文件包含漏洞)</h2><p><strong>1.本地文件包含漏洞：</strong>仅能够对服务器本地的文件进行包含，由于服务器上的文件并不是攻击者所能够控制的，因此该情况下，攻击着更多的会包含一些 固定的系统配置文件，从而读取系统敏感信息。很多时候本地文件包含漏洞会结合一些特殊的文件上传漏洞，从而形成更大的威力。</p><p><strong>2.远程文件包含漏洞：</strong>能够通过url地址对远程的文件进行包含，这意味着攻击者可以传入任意的代码，这种情况没啥好说的，准备挂彩。   </p><h2 id="不安全的文件下载"><a href="#不安全的文件下载" class="headerlink" title="不安全的文件下载"></a>不安全的文件下载</h2><p><strong>切记：所有与前端交互的数据都是不安全的，不能掉以轻心</strong></p><p>一般后台下载文件是直接将文件名称并入下载文件中的路径，但如果名字有问题 ，比如改成了一个路径指向后台敏感信息，则可能导致信息泄露。     </p>]]></content>
      
      
      
        <tags>
            
            <tag> web ctf pikachu </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
